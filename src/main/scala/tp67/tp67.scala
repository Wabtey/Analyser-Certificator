// Code generated by Isabelle
package tp67

import utilities.Datatype._
import scala.language.implicitConversions

// automatic conversion of utilities.Datatype.Int.int to Int.int
object AutomaticConversion {
  implicit def int2int(i: utilities.Datatype.Int.int): Int.int =
    i match {
      case utilities.Datatype.Int.int_of_integer(i) => Int.int_of_integer(i)
    }

  def bit_cut_integer(k: BigInt): (BigInt, Boolean) =
    (if (k == BigInt(0)) (BigInt(0), false)
     else {
       val (r, s): (BigInt, BigInt) =
         (
             (k: BigInt) =>
               (l: BigInt) =>
                 if (l == 0) (BigInt(0), k)
                 else
                   (k.abs /% l.abs)
         ).apply(k).apply(BigInt(2));
       ((if (BigInt(0) < k) r else (-r) - s), s == BigInt(1))
     })

  def char_of_integer(k: BigInt): String.char = {
    val (q0, b0): (BigInt, Boolean) = bit_cut_integer(k)
    val (q1, b1): (BigInt, Boolean) = bit_cut_integer(q0)
    val (q2, b2): (BigInt, Boolean) = bit_cut_integer(q1)
    val (q3, b3): (BigInt, Boolean) = bit_cut_integer(q2)
    val (q4, b4): (BigInt, Boolean) = bit_cut_integer(q3)
    val (q5, b5): (BigInt, Boolean) = bit_cut_integer(q4)
    val (q6, b6): (BigInt, Boolean) = bit_cut_integer(q5)
    val a: (BigInt, Boolean) = bit_cut_integer(q6)
    val (_, aa): (BigInt, Boolean) = a;
    String.Chara(b0, b1, b2, b3, b4, b5, b6, aa)
  }

  def map[A, B](f: A => B, x1: List[A]): List[B] = (f, x1) match {
    case (f, Nil)     => Nil
    case (f, x :: xs) => f(x) :: map[A, B](f, xs)
  }

  def explodeList(l: List[Char]): List[String.char] = {
    (l.map(c => {
      val k: Int = c.toInt;
      if (k < 128) BigInt(k) else sys.error("Non-ASCII character in literal")
    }))
      .map(a => char_of_integer(a))
  }

  def explode(s: String): List[String.char] = {
    explodeList(s.toCharArray.toList)
  }

  // conversion from Scala String to HOL string
  implicit def string2charList(s: String): List[String.char] = explode(s)

  // conversion from Scala List[Char] to HOL List[String.char]
  implicit def charList2charList(l: List[Char]): List[String.char] =
    explodeList(l)
  // conversion of a pair with a Scala List[String] on the first position
  // to an HOL pair with an HOL List[String.char] on first position
  implicit def tupleString2tupleString[T](
      t: (List[Char], T)
  ): (List[String.char], T) = t match {
    case (e1, e2) => (charList2charList(e1), e2)
  }

  // conversion from Isabelle Int.int to Project Int.int
  implicit def int2Dataint(i: Int.int): utilities.Datatype.Int.int =
    i match {
      case Int.int_of_integer(i) => utilities.Datatype.Int.int_of_integer(i)
    }

  def stringChar2char(x: String.char): Char = {
    x match {
      case String.Chara(x1, x2, x3, x4, x5, x6, x7, x8) => {
        var n = 0;
        n = if (x8) 2 * n + 1 else 2 * n;
        n = if (x7) 2 * n + 1 else 2 * n;
        n = if (x6) 2 * n + 1 else 2 * n;
        n = if (x5) 2 * n + 1 else 2 * n;
        n = if (x4) 2 * n + 1 else 2 * n;
        n = if (x3) 2 * n + 1 else 2 * n;
        n = if (x2) 2 * n + 1 else 2 * n;
        n = if (x1) 2 * n + 1 else 2 * n;
        n.toChar
      }
    }
  }

  // conversion from Isabelle String to Lists of Chars
  implicit def charList2String(l: List[String.char]): List[Char] = {
    l.map(stringChar2char(_))
  }
}

import AutomaticConversion._

object Code_Numeral {

  def integer_of_int(x0: Int.int): BigInt = x0 match {
    case Int.int_of_integer(k) => k
  }

} /* object Code_Numeral */

object Int {

  abstract sealed class int
  final case class int_of_integer(a: BigInt) extends int

  def zero_int: int = int_of_integer(BigInt(0))

  def equal_int(k: int, l: int): Boolean =
    Code_Numeral.integer_of_int(k) == Code_Numeral.integer_of_int(l)

} /* object Int */

object String {

  abstract sealed class char
  final case class Chara(
      a: Boolean,
      b: Boolean,
      c: Boolean,
      d: Boolean,
      e: Boolean,
      f: Boolean,
      g: Boolean,
      h: Boolean
  ) extends char

} /* object String */

object tp67 {

  def sanconstant(x0: statement): Boolean = x0 match {
    case Seq(s1, s2)       => sanconstant(s1) && sanconstant(s2)
    case If(uu, s1, s2)    => sanconstant(s1) && sanconstant(s2)
    case Exec(Constant(c)) => !(Int.equal_int(c, Int.zero_int))
    case Exec(Variable(v)) => false
    case Exec(Sum(v, va))  => false
    case Exec(Sub(v, va))  => false
    case Aff(v, va)        => true
    case Read(v)           => true
    case Print(v)          => true
    case Skip              => true
  }

} /* object tp67 */
